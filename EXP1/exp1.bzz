 ##################
##### UTILS ######
##################
# TODO Move to ../utils.zz

include "vec2.bzz"

# robot needs a local var  distanceEvent = {} to store the distance event
function addDistanceEvent(distance,callback,condition){
    distanceEvent[distanceEvent.size()] = {.distance = distance, .callback=callback,.condition = condition}
}

function checkDistanceEvent(distance){
    foreach (distanceEvent, function(key,value){
        neighbors.foreach(function(rid, data) {
            if(neighbors.get(rid).distance <= value.distance and value.condition(rid,data)){
                value.callback(rid,data)
            }
        })
    })
}
##################
##### MAIN ######
##################

POSSIBLE_STATES = {}
POSSIBLE_STATES[0] = "succeptible"
POSSIBLE_STATES[1] = "infected"

SPEED = 5.0

function give_state() {
    math.rng.setseed(id)
    var rand = math.rng.uniform(0,100)
    var index = 0
    if (rand > 90) {
        index = 1
    }
    var state = POSSIBLE_STATES[index]
    return state
}

function random_move () {
    sensors = {}
    value = -1
    var counter = 0
    while(counter < 8) {
        var frontValue = proximity[counter].value
        var frontAngle = proximity[counter].angle
        sensors[counter] = frontValue
        counter = counter + 1
        if (value < frontValue) {
            value = frontValue
        } 
    }
    if (sensors[2] != 0 or sensors[6] != 0 or sensors[1] != 0 or sensors[0] != 0 or sensors[7] != 0) {
        set_wheels(SPEED,-SPEED)
    }
    else {
        set_wheels(SPEED,SPEED)
    }
}

function cluster_move() {
    var coord = {}
    coord.x = 0.0
    coord.y = 0.0
    var x1 = pose.position.x
    #log(x1)
    var y1 = pose.position.y
    var x2 = coord.x
    var y2 = coord.y
    #log(x2,y2)
    var vec = {}
    vec.x = x2 - x1
    vec.y = y2 - y1
    #log(id,":",vec.x,";",vec.y)
    vec = math.vec2.norm(vec)
    #log(id,":",vec.x,";",vec.y)
    vec = math.vec2.scale(vec,10.0)
    #log(id,":",vec.x,";",vec.y)
    #log(id,":",vec.x,";",vec.y)
    var theta = -pose.orientation.yaw
    log(id,":",theta)
    var sin_theta = math.sin(theta)
    var cos_theta = math.cos(theta)
    vec.x = cos_theta * vec.x - sin_theta * vec.y
    vec.y = sin_theta * vec.x + cos_theta * vec.y
    log(id,":",x1,";",y1)
    #log(id,":",x1,";",y1)
    goto(vec.x,vec.y)
}

function cluster_move_2() {
    current_x = pose.position.x
    current_y = pose.position.y
    
    y = 4.0 - current_y
    x = 4.0 - current_x
    #log("truc",y,x)
    var angle = math.atan(y,x)
    #log("angle : ",angle)
    angle = angle - pose.orientation.yaw
    vec = math.vec2.newp(10.0,angle)
    #log(vec.x,vec.y)
    goto(vec.x,vec.y)
}

# Executed at init time
function init() {
    distanceEvent = {}
    # ajoute un print obligatoire lorsque la distance est inférieure à 0.5
    #addDistanceEvent(0.5,function(rid,data){
    #    print("distance 0.5")
    #},function(rid,data){
    #    return true
    #})
    robot_state = give_state()
    #log(robot_state)
    s = swarm.create(1)
    s.select(id >= 0)
}

# Executed every time step
function step() {
    #s.exec(random_move)
    var target = {}
    target.x = 0.0
    target.y = 0.0
    s.exec(cluster_move_2)
    #log(pose.orientation.yaw)
    
    #log(vec.x,":",vec.y)
    #log(id,":",pose.position.x,",",pose.position.y)
    #log(id,":",math.rng.uniform(0,100))
}



function reset(){
}

# Execute at exit
function destroy() {
}
