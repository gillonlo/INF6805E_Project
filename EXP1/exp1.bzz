include "vec2.bzz"

POSSIBLE_STATES = {}
POSSIBLE_STATES[0] = "succeptible"
POSSIBLE_STATES[1] = "infected"

STATES_COLORS = {}
STATES_COLORS[0] = {.r = 0, .g = 255, .b = 0}
STATES_COLORS[1] = {.r = 255, .g = 0, .b = 0}

SPEED = 5.0

NB_CLUSTERS = 4
CLUSTERS = {}
CLUSTERS[0] = {.x = 3.0, .y = 3.0}
CLUSTERS[1] = {.x = 3.0, .y = -3.0}
CLUSTERS[2] = {.x = -3.0, .y = 3.0}
CLUSTERS[3] = {.x = -3.0, .y = -3.0}

function give_state() {
    math.rng.setseed(id)
    var rand = math.rng.uniform(0,100)
    index = 0
    if (rand > 90) {
        index = 1
    }
    var state = POSSIBLE_STATES[index]
    return state
}

function save_stats(){

		result_file = io.fopen("data.csv", "a")
		io.fwrite(result_file, current_step,";",id,";", robot_state )
		io.fclose(result_file)

}
function clear_stats(){
result_file = io.fopen("data.csv", "w")
io.fwrite(result_file, "step;id;state" )
io.fclose(result_file)
 #TODO
}

function random_move () {
    var sensors = {}
    var value = -1
    var counter = 0
    while(counter < 8) {
        var frontValue = proximity[counter].value
        var frontAngle = proximity[counter].angle
        sensors[counter] = frontValue
        counter = counter + 1
        if (value < frontValue) {
            value = frontValue
        } 
    }
    if (sensors[2] != 0 or sensors[6] != 0 or sensors[1] != 0 or sensors[0] != 0 or sensors[7] != 0) {
        set_wheels(SPEED,-SPEED)
    }
    else {
        set_wheels(SPEED,SPEED)
    }
}

function cluster_move() {
    var current_x = pose.position.x
    var current_y = pose.position.y

    var target_cluster = CLUSTERS[rand]

    var y = target_cluster.y - current_y
    var x = target_cluster.x - current_x

    var angle = math.atan(y,x)
    angle = angle - pose.orientation.yaw

    var vec = math.vec2.newp(10.0,angle)

    goto(vec.x,vec.y)
}

function distance_to_cluster() {
    var current_x = pose.position.x
    var current_y = pose.position.y
    var target_cluster = CLUSTERS[rand]
    return math.sqrt((current_x-target_cluster.x)^2 + (current_y-target_cluster.y)^2)
}

# Executed at init time
function init() {
    robot_state = give_state()
    change_clusters = 1
    s = swarm.create(1)
    s.select(id >= 0)
    v = stigmergy.create(1)
    v.put(string.tostring(id),index)
    current_step = 0
		clear_stats()
}

function edpidemics_spread() {
    if (robot_state == "succeptible") {
        neighbors.foreach(function(rid, data) {
            if (data.distance < 30.0) {
                rid_string = string.tostring(rid)
                log(rid_string,v.get(rid_string))
                if (v.get(rid_string) == 1) {
                    robot_state = "infected"
                    index = 1
                    id_string = string.tostring(id)
                    v.put(id_string,index)
                }
            }
        })
    }
}

# Executed every time step
function step() {
    if (change_clusters == 1) {
        rand = math.rng.uniform(0,NB_CLUSTERS)
        change_clusters = 0
        steps_delay = math.rng.uniform(1,10)*10
    }
    s.exec(cluster_move)
    var distance = distance_to_cluster()
    if (distance < 0.5) {
        steps_delay = steps_delay - 1
    }   
    if (steps_delay == 0) {
        change_clusters = 1
    }
    s.exec(edpidemics_spread)
    set_leds(STATES_COLORS[index].r,STATES_COLORS[index].g,STATES_COLORS[index].b)
		current_step = current_step + 1
		save_stats()
}

function reset(){
}

# Execute at exit
function destroy() {
}
